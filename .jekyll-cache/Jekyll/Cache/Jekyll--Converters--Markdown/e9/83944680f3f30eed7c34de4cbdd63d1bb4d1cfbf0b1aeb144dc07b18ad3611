I"u3<h4 id="contents">Contents</h4>
<ul>
  <li><a href="#PIVOT-operator의-기본형태">PIVOT operator의 기본형태</a></li>
  <li><a href="#PIVOT-operator-예시">PIVOT operator 예시</a></li>
  <li><a href="#PIVOT-operator-활용하기">PIVOT operator 활용하기</a>
    <ul>
      <li><a href="#만약-그룹별로-나누어서-보고자하는-케이스가-2종류일-경우">만약 그룹별로 나누어서 보고자하는 케이스가 2종류일 경우</a></li>
      <li><a href="#Dynamically-generating-pivot-column-values">Dynamically generating pivot column values</a></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>본 포스팅은 Bigquery의 PIVOT OPERATOR에 관한 내용을 담고 있습니다.</p>

<hr />

<p><br /></p>

<p>오랜만에 Google Cloud 출시 노트를 확인하던 중 Bigquery를 사용하는 사람이라면 가슴을 두근거리게 만드는 기능이 2021년 5월 10일에 테스트로 출시된 것을 확인하였다!</p>

<p><br /></p>

<p>그 Operator는 ORACLE에서는 흔하게 보고 쓸 수 있지만, Biguqery에서는 “왜 이게 없지? 🤔”를 매번 생각하게 만들었던  <code class="language-plaintext highlighter-rouge">PIVOT Operator</code>이다. 심지어 <code class="language-plaintext highlighter-rouge">UNPIVOT</code>도 같이 추가된 것을 확인할 수 있다. <code class="language-plaintext highlighter-rouge">UNPIVOT</code>의 경우는 2020년에 추가된 <code class="language-plaintext highlighter-rouge">fhoffa.x.unpivot()</code>으로도 대체할 수 있지만 뭔가 세트메뉴처럼 나온게 감격스러웠다.  더불어, QUALIFY라는 Operator도 추가된 것을 확인할 수 있었는데 이 또한 사용자의 편의성을 높여주는 Operator였었다. 차후에 이것에 관해서도 블로그에 정리해볼 예정이다. (단지, 한 가지 이 기능들에 관해서 불안한 점은 Preview Version이라는 점이다….😕)</p>

<p><img src="https://user-images.githubusercontent.com/53929665/120649430-b7676d00-c4b7-11eb-993b-743e1bed39ed.JPG" alt="2" /></p>

<p><br /></p>

<p>이제 아무말 대잔치였던 서론은 끝내고 새로 출시된 <code class="language-plaintext highlighter-rouge">PIVOT</code> Operator에 관하여 알아보자.</p>

<p><br /></p>

<hr />

<h3 id="pivot-operator의-기본형태">PIVOT operator의 기본형태</h3>

<p>다음은 Bigquery Documents에서 제시하는 기본 포맷이다.</p>

<pre><code class="language-SQL">
FROM  from_item[,  ...]  pivot_operator  
  
pivot_operator: PIVOT(  aggregate_function_call  [as_alias][,  ...]  FOR  input_column  IN  (  pivot_column  [as_alias][,  ...]  )  )  [AS  alias]  
  
as_alias:  [AS]  alias

</code></pre>

<p>포맷만 보았을 때, 가장 눈에 띄는 점은 아래와 같았다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">PIVOT</code>operator가 <code class="language-plaintext highlighter-rouge">FROM</code> 절의 일부분으로 명시된 테이블 뒤에  사용한다는 점</li>
  <li>중간 중간에 별칭(alias)을 명시 할 수 있다는 점</li>
  <li>집계 함수(aggregate_function) 가 사용되어진다는 점</li>
</ul>

<p><br /></p>

<p>그리고,  각 주요 변수들을 다음과 같이 정의되어진다.</p>
<pre><code class="language-SQL">PIVOT( {aggregate_function_call}  FOR {input_column} IN({pivot_column}))
</code></pre>
<ul>
  <li><code class="language-plaintext highlighter-rouge">input_column</code> :  c olumn으로 옮기고자(즉, Pivot하고자)하는 row 데이터를 가진 column</li>
  <li><code class="language-plaintext highlighter-rouge">pivot_column</code> : 집계함수를 통해 pivot column으로 변환되어질 input column의 row데이터</li>
  <li><code class="language-plaintext highlighter-rouge">aggregate_function_call</code> :  input column을 집계하기위해 호출되어지는 집계함수</li>
</ul>

<p><br /></p>

<p>다음으로 pivot 기능을 예시를 통하여 어떻게 사용하는지 확인해보자.</p>

<p><br /></p>

<hr />

<h3 id="pivot-operator-예시">PIVOT operator 예시</h3>

<p>*다음은 Bigquery에서 Public으로 공개하는 <code class="language-plaintext highlighter-rouge">london_bicycles</code> 데이터셋의 <code class="language-plaintext highlighter-rouge">cycle_hire</code>테이블을 이용한 예시이다.</p>

<p>각 필드는 다음을 의미한다고 가정할 것이다.</p>
<ul>
  <li>bike_id : 자전거 고유 번호</li>
  <li>start_date : 자전거 대여 시간</li>
  <li>end_date : 자전거 반납 시간</li>
  <li>duration : 자전거 대여 시간 (end_date - start_date, unit is sec)</li>
  <li>start_station_name : 자전거 대여한 스테이션 위치</li>
  <li>end_station_name : 자전거를 반납한 스테이션 위치</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/53929665/120658195-2fd22c00-c4c0-11eb-8730-08dc1ad62443.JPG" alt="3" /></p>

<p><br /></p>

<p>해당 데이터를 통해,  Queen Street 2, Bank의 자전거 스테이션에서 각 end_station까지 걸린 이용시간의 일별 평균을 구하면 다음과 같을 것이다. 하지만, 집계되어지는 행 수는 무려35950개이다. 이는 가독성이 떨어질 뿐 만 아니라, 중요 인사이트를 얻기에는 효과적이지 않으며, Redash나 Data Studio를 통해 데이터를  시각화하기 불편한다. 따라서, PIVOT 시킬 필요가 있다.</p>

<p><img src="https://user-images.githubusercontent.com/53929665/120660856-ba1b8f80-c4c2-11eb-96ad-57fa265058cf.JPG" alt="4" /></p>

<p><br /></p>

<p>PIVOT Operator가 없던 시절(라떼는 말이야… ☕)에는  <code class="language-plaintext highlighter-rouge">MAX</code>(혹은 다른 집계함수)와 <code class="language-plaintext highlighter-rouge">IF</code>를 이용해서 Pivot Column으로 생성하고자하는 열의 값들을 하나 하나 열거 했을 것이다(<a href="https://corecompete.com/how-to-build-pivot-tables-in-bigquery-fast-and-easy/">참조링크</a>).  하지만, PIVOT함수를 사용하면 다음과 같이 나타낼 수 있다.  하지만, 아래에서 확인할 수 있듯이 PIVOT Column들을 열거해야한다는 불편함은 온전하였다… 😅</p>

<p><img src="https://user-images.githubusercontent.com/53929665/120664413-dd940980-c4c5-11eb-8774-2cb1faa2fd28.JPG" alt="5" /></p>

<p><br /></p>

<p>더불어, 보통의 쿼리들과 동일하게  <code class="language-plaintext highlighter-rouge">WHERE</code>과 <code class="language-plaintext highlighter-rouge">ORDER BY</code>절을 이용하여  <code class="language-plaintext highlighter-rouge">PIVOT</code>으로 인하여 집계된 column에 필터를 만들거나 오름차순이나 내림차순으로도 정렬을 해줄 수도 있다.</p>

<p><img src="https://user-images.githubusercontent.com/53929665/120666370-7f682600-c4c7-11eb-8e05-da7e500426df.JPG" alt="6" /></p>

<p><br /></p>

<p>다음은 해당 operator를 조금 더 유용하게 활용할 몇가지 방법에 관하여 알아보자.</p>

<p><br /></p>

<hr />

<h3 id="pivot-operator-활용하기">PIVOT operator 활용하기</h3>

<h4 id="만약-그룹별로-나누어서-보고자하는-케이스가-2종류일-경우">만약 그룹별로 나누어서 보고자하는 케이스가 2종류일 경우</h4>

<p>위의 사용 예제에서는  Queen Street 2, Bank의 자전거 스테이션에서 시작하는 케이스만 확인하였다. 하지만, 만약 Queen Street 1, Bank과 Waterloo Station 3, Waterloo도 같이 확인하고 이들을 <code class="language-plaintext highlighter-rouge">PIVOT</code> operator를 이용해서 피벗하고 싶을 경우에는 어떻게하면 좋을까?</p>

<p>쿼리로는 다음과 같이 각 start_station별로 AVG집계를 진행한다.</p>
<pre><code class="language-SQL">SELECT  DATE(start_date)  AS start_date, end_station_name,
		AVG(IF(start_station_name = 'Queen Street 2, Bank', duration, NULL))  AS avg_duration_for_street2,
		AVG(IF(start_station_name = 'Queen Street 1, Bank', duration, NULL))  AS avg_duration_for_stree1,
		AVG(IF(start_station_name = 'Waterloo Station 3, Waterloo', duration, NULL))  AS avg_duration_for_Waterloo

FROM  `bigquery-public-data.london_bicycles.cycle_hire`
WHERE start_station_name IN('Queen Street 2, Bank', 'Queen Street 1, Bank', 'Waterloo Station 3, Waterloo')
GROUP  BY  1, 2
</code></pre>
<p>출력된 결과는 아래와 같다.</p>

<p><img src="https://user-images.githubusercontent.com/53929665/120669491-79277900-c4ca-11eb-869c-e9295f411c75.JPG" alt="7" /></p>

<p><br /></p>

<p>그리고, 이 상황에서 pivot column으로 아래와 같이 생성하고자 한다.</p>

<ul>
  <li>Waterloo Station 3, Waterloo에 대해서
    <ul>
      <li>waterloo_2017_06_01</li>
      <li>waterloo_2017_06_02</li>
      <li>waterloo_2017_06_03</li>
    </ul>
  </li>
  <li>Queen Street 1, Bank에 대해서
    <ul>
      <li>street1_2017_06_01</li>
      <li>street1_2017_06_02</li>
      <li>street1_2017_06_03</li>
    </ul>
  </li>
  <li>Queen Street 2, Bank에 대해서
    <ul>
      <li>street2_2017_06_01</li>
      <li>street2_2017_06_02</li>
      <li>street2_2017_06_03</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>이 경우에는 아래와 같이 집계함수와 alias를 적절하게 이용하면 쉽게 표현가능하다.</p>
<pre><code class="language-SQL">SELECT  *
FROM temp0
PIVOT(	
		MAX(avg_duration_for_Waterloo)  AS waterloo,
		MAX(avg_duration_for_stree1)  AS street1,
		MAX(avg_duration_for_street2)  AS street2
		FOR start_date IN('2017-06-01', '2017-06-02', '2017-06-03')
	 )
WHERE waterloo_2017_06_01 IS  NOT  NULL
</code></pre>

<p>아래의 결과를 통해 계획 했던 pivot column들이 모두 생성된 것을 확인할 수 있었다.</p>

<p><img src="https://user-images.githubusercontent.com/53929665/120670104-0bc81800-c4cb-11eb-9419-97281e58a45e.JPG" alt="8" /></p>

<p>이는 단순히 위에서 언급했던 <code class="language-plaintext highlighter-rouge">AVG(IF...)</code>를 9번 열거해서 위와 같이 구성할 수 있지만, 만약 표현하고자하는 필드 수가 기하급수적으로 많아질 경우 개인적으로는 해당 방법이 더 심리적으로나 시각적으로나 개인적으로 더 나았다.</p>

<p><br /></p>

<h4 id="dynamically-generating-pivot-column-values">Dynamically generating pivot column values</h4>

<p><code class="language-plaintext highlighter-rouge">PIVOT</code> Operator가 편리한 것 같아 보이지만,  pivot 시키고자하는 column이 많아질수록  <code class="language-plaintext highlighter-rouge">IN(  )</code>안에 기입해야할 pivot_column도 비례하여 늘어난다.  더불어,  <code class="language-plaintext highlighter-rouge">IN( )</code>안에  <code class="language-plaintext highlighter-rouge">SELECT</code>절, <code class="language-plaintext highlighter-rouge">ARRAY</code>등을 기입할 수 없다.</p>

<p><br /></p>

<p>이러한  불편함을 조금이라도 해결할 수 있는 방법을 다음의 <a href="https://towardsdatascience.com/how-to-use-dynamic-sql-in-bigquery-8c04dcc0f0de">Medium링크</a>에서 확인할 수 있었다.</p>

<p><br /></p>

<p>이 방법의 핵심은 <code class="language-plaintext highlighter-rouge">EXECUTE IMMEDIATE</code>이다.</p>

<pre><code class="language-SQL">DECLARE duration_range STRING;
SET  duration_range =
(
	SELECT  CONCAT('(', ARRAY_TO_STRING(ARRAY_AGG(CONCAT('"',CAST(duration AS  STRING), '"')), ', '), ')')
	FROM  UNNEST(GENERATE_DATE_ARRAY('2017-06-01', '2017-06-03'))  AS duration
);

  
EXECUTE  IMMEDIATE  format("""

	WITH temp0 AS
	(
		SELECT  DATE(start_date)  AS start_date, end_station_name, AVG(duration)  AS avg_duration
		FROM  `bigquery-public-data.london_bicycles.cycle_hire`
		WHERE  start_station_name = 'Waterloo Station 3, Waterloo'
		GROUP  BY  1, 2
	)

	SELECT  *

	FROM temp0
	PIVOT(MAX(avg_duration) FOR start_date IN  %s)

""", duration_range);

</code></pre>

<p><br /></p>

<p>해당 방법에 관해서는 아직 개인적으로 확실하지 않은 것도 많으며 이해되지 않는 것도 많다. 따라서,  <code class="language-plaintext highlighter-rouge">PIVOT</code>을 더 유용하게 사용하기 위해서 스크립팅문에 관해서 더 공부할 필요가 있어보인다 🤔</p>

<p><br /></p>

<hr />

<h3 id="references">References</h3>

<ul>
  <li><a href="https://corecompete.com/how-to-build-pivot-tables-in-bigquery-fast-and-easy/">CORECOMPETE, A Fast Approach to Building Pivot Table / Transpose Functionality into BigQuery</a></li>
  <li><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#rules_for_pivot_agg_function">BigQuery Pivot Document</a></li>
  <li><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting#execute_immediate">BigQuery Scripting statements</a></li>
  <li><a href="https://towardsdatascience.com/pivot-in-bigquery-4eefde28b3be">towardsdatascience, PIVOT in Bigquery</a></li>
  <li><a href="https://towardsdatascience.com/how-to-use-dynamic-sql-in-bigquery-8c04dcc0f0de">towardsdatascience, How to use Dynamic SQL in BigQuery</a></li>
</ul>

:ET