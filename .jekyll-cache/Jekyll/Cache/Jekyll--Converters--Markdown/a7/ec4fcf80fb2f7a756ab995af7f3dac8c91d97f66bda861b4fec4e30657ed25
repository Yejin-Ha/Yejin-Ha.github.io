I"0<h2 id="-지도-학습">[ 지도 학습]</h2>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">지도 학습(supervised learning)</code> :
    <ul>
      <li>주어진 입력으로부터 출력을 예측하고자 할 때 사용한다.</li>
      <li>입력/출력 샘플 데이터, 즉 훈련 세트로부터 머신러닝 모델을 만든다.</li>
      <li>종종 훈련 데이터를 만드는 데 사람의 노력이 필요하지만 자동화하면 힘들고 어려운 작업의 속도를 높일 수 있다.</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="-1-분류와-회귀-">[ 1. 분류와 회귀 ]</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">분류(classification)</code> : 미리 정의된, 가능성 있는 여러 <code class="language-plaintext highlighter-rouge">클래스 레이블(class label)</code>중 하나를 예측하는 것
    <ul>
      <li><code class="language-plaintext highlighter-rouge">이진 분류(binary classification)</code> : 두개의 클래스로 분류 (ex. yes/no)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">양성(positive)</code> 클래스 : 학습하고자하는 대상 (ex. 스팸메일입니까? -&gt; 스팸메일 클래스 = 양성)</li>
          <li><code class="language-plaintext highlighter-rouge">음성(negative)</code> 클래스 : 나머지</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">다중 분류(multiclass classification)</code> : 셋 이상의 클래스로 분류 (ex. 붓꽃, 웹사이트의 언어 예측)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">회귀(regression)</code> : 연속적인 숫자, 또는 <code class="language-plaintext highlighter-rouge">부동소수점수(실수)</code>를 예측하는 것
    <ul>
      <li>ex1. 어떤 사람의 교육 수준,나이,주거지로 연간 소득(숫자,양) 예측</li>
      <li>ex2. 옥수수 농장에서 전년도 수확량과 날씨, 고용 인원수등으로 올해 수확량(숫자)을 예측</li>
      <li>예상 출력 값 사이에 연속성이 있다면 회귀 문제에 해당한다.</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="-2-일반화-과대적합-과소적합-">[ 2. 일반화, 과대적합, 과소적합 ]</h3>

<h4 id="1-일반화-과대적합-과소적합">(1) 일반화, 과대적합, 과소적합</h4>

<blockquote>
  <p>지도학습에서 훈련 데이터로 학습한 모델이 훈련 데이터와 특성이 같다면<br />
처음 보는 새로운 데이터가 주어져도 정확히 예측할 거라 기대한다.</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">일반화(generalization)</code> :
    <ul>
      <li>모델이 처음 보는 데이터에 대해 정확하게 예측할 수 있는 경우, <br />
이를 훈련 세트에서 테스트세트로 일반화되었다고 한다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>모델을 복잡하게 할수록 훈련 데이터에 대해서는 더 정확히 예측할 수 있다.<br />
그러나 너무 복잡해지면 훈련 세트의 각 데이터 포인트에 너무 민감해져 새로운 데이터에 잘 일반화되지 못한다!</p>

  <p>☑ 찾아야 하는 모델은 일반화 성능이 최대가 되는 최적점에 있는 모델이다.</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">과대적합(overfitting)</code> :
    <ul>
      <li>가진 정보를 모두 사용해서 너무 복잡한 모델을 만드는 것</li>
      <li>모델이 훈련 세트의 샘플에 너무 가깝게 맞춰져서 새로운 데이터에 일반화되기 어려울 때 일어난다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">과소적합(underfitting)</code> :
    <ul>
      <li>과대적합과 반대로 너무 간단한 모델이 선택되는 것</li>
    </ul>
  </li>
</ul>

<p><img width="400" alt="1" src="https://user-images.githubusercontent.com/53929665/97110512-16dced80-171d-11eb-8aa6-07a6308fae13.PNG" /></p>

<h4 id="2-모델-복잡도와-데이터셋-크기의-관계">(2) 모델 복잡도와 데이터셋 크기의 관계</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">모델 복잡도</code>는 훈련 데이터셋에 담긴 <code class="language-plaintext highlighter-rouge">입력 데이터의 다양성</code>과 관련이 깊다.
    <ul>
      <li>데이터셋에 다양한 데이터 포인트 多 -&gt; 과대적합이 없는 더 복잡도 있는 모델 만들 가능성 up<br />
  ( 테스트 샘플에서도 예측을 잘하며 모델이 좀더 세밀해진다는 의미)</li>
      <li>But, 같은 데이터 포인트를 중복하거나 매우 비슷한 데이터를 모으는 것은 도움x</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="-3-지도-학습-알고리즘-">[ 3. 지도 학습 알고리즘 ]</h3>
<h4 id="1-예제에-사용할-데이터셋">(1) 예제에 사용할 데이터셋</h4>
<h4 id="1-1-forge-데이터셋">(1-1) <code class="language-plaintext highlighter-rouge">forge</code> 데이터셋</h4>
<ul>
  <li>두 개의 특성을 가진 <code class="language-plaintext highlighter-rouge">forge</code> 데이터셋은 인위적으로 만든 이진 분류 데이터셋이다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">ps</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="n">sns</span>
<span class="kn">import</span> <span class="nn">mglearn</span>

<span class="c1"># 데이터셋을 만든다.
</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mglearn</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">make_forge</span><span class="p">()</span>
<span class="c1"># 산점도를 그린다.
</span><span class="n">mglearn</span><span class="p">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span> <span class="c1">#  X는 데이터값 y는 데이터레이블을 의미함
</span><span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'class 0'</span><span class="p">,</span><span class="s">'class 1'</span><span class="p">],</span> <span class="n">loc</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>    <span class="c1"># loc옵션은 legend의 위치를 나타낸다.
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'first_property'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'second_property'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'X.shape'</span><span class="p">,</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

<span class="c1"># 발생하는 오류는 mglearn을 제작하신 분이 무시해도 상관없다고함...
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X.shape (26, 2)
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110564-42f86e80-171d-11eb-94c8-43b04f5e6b44.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_3_2" /></p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">X.shape</code>값에서 알 수 있듯이 이 데이터셋은 데이터 포인트 26개와 특성 2개를 가진다.</p>
</blockquote>

<h4 id="1-2-wave-데이터셋">(1-2) <code class="language-plaintext highlighter-rouge">wave</code> 데이터셋</h4>
<ul>
  <li>회귀 알고리즘 설명에는 인위적으로 만든 <code class="language-plaintext highlighter-rouge">wave</code> 데이터셋을 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">wave</code> 데이터셋은 입력 특성 하나와 모델링할 타깃 변수(또는 응답)을 가진다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mglearn</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">make_wave</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>     <span class="c1"># n_samples옵션은 데이터 셈플의 갯수
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">'o'</span><span class="p">)</span>                                   <span class="c1"># X[n,0]의 짝 y[n]
</span><span class="n">plt</span><span class="p">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>                                     <span class="c1"># y축 범위
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'property'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'target'</span><span class="p">)</span>
<span class="c1"># for i, v in enumerate(X):
#     plt.text(v, y[i], y[i],                 # 좌표 (x축 = v, y축 = y[0]..y[1], 표시 = y[0]..y[1])
#              fontsize = 9, 
#              color='blue',
#              horizontalalignment='center',  # horizontalalignment (left, center, right)
#              verticalalignment='bottom')    # verticalalignment (top, center, bottom)
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0, 0.5, 'target')
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110565-44299b80-171d-11eb-8c21-666f9dad3ea6.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_6_1" /></p>

<h4 id="1-3-cancer-데이터셋">(1-3) <code class="language-plaintext highlighter-rouge">cancer</code> 데이터셋</h4>
<ul>
  <li>인위적인 소규모 데이터셋 외에 <code class="language-plaintext highlighter-rouge">scikit-learn</code>에 들어 있는 유방암 종양의 임상 데이터를 기록해놓은 위스콘신 유방암 데이터셋(<code class="language-plaintext highlighter-rouge">cancer</code>)이다.
    <ul>
      <li>각 종양은 양성과 악성으로 레이블되어 있고</li>
      <li>조직 데이터를 기반으로 종양이 악성인지를 예측할 수 있도록 학습하는 것이 과제이다.</li>
    </ul>
  </li>
  <li>이 데이터는 <code class="language-plaintext highlighter-rouge">scikit-learn</code>에 있는 <code class="language-plaintext highlighter-rouge">load_breast_cancer</code> 함수에서 로드하여 쓸 수 있다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_breast_cancer</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">cancer</span> <span class="o">=</span> <span class="n">load_breast_cancer</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'cancer.keys():</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span> <span class="n">cancer</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cancer.keys():
 dict_keys(['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names', 'filename'])
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'유방암 데이터의 형태 :'</span><span class="p">,</span> <span class="n">cancer</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>유방암 데이터의 형태 : (569, 30)
</code></pre></div></div>

<ul>
  <li>569개의 데이터 포인트를 가지고 있고 특성은 30개이다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'클래스별 샘플 개수 :'</span><span class="p">,</span> 
         <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cancer</span><span class="p">.</span><span class="n">target_names</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">cancer</span><span class="p">.</span><span class="n">target</span><span class="p">))})</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>클래스별 샘플 개수 : {'malignant': 212, 'benign': 357}
</code></pre></div></div>

<ul>
  <li>
    <p>앞서, <code class="language-plaintext highlighter-rouge">cancer.data</code>에서 569개의 유방암 데이터를 확인했다는 것을 염두하자</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">cancer.target</code>은 0과 1로 이루어진 배열을 가진 리스트이다.</li>
  <li>이 객체에 <code class="language-plaintext highlighter-rouge">bincount()</code>함수를 적용하면 0과 1의 빈도 수를 반환한다.</li>
  <li>각각 0은 악성종양, 1은 양성종양을 의미한다.</li>
  <li>
    <p>따라서, <code class="language-plaintext highlighter-rouge">np.bincount(cancer.target)</code>을 실행하면 <code class="language-plaintext highlighter-rouge">array([212, 357], dtype=int64)</code>가 반환된다. 즉, 0은 212개 1은 357개라는 의미이다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">cancer.target_names</code> maliganant(악성), benign(양성) value를 리스트 형태로 가지고있다.</li>
  <li>
    <p>따라서, <code class="language-plaintext highlighter-rouge">zip</code>함수를 이용하여 maliganant의 빈도 수와 benign의 빈도 수를 동시에 반환시킬 수 있다.</p>
  </li>
  <li>마지막으로, 리스트내포에서의 반복문을 이용하여 연결된 리스트들을 모두 반환하였다.</li>
  <li>결론적으로, 출력물은 malignant(악성) 데이터 212개, benign(양성) 데이터 357개를 의미한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'특성 이름:</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span> <span class="n">cancer</span><span class="p">.</span><span class="n">feature_names</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>특성 이름:
 ['mean radius' 'mean texture' 'mean perimeter' 'mean area'
 'mean smoothness' 'mean compactness' 'mean concavity'
 'mean concave points' 'mean symmetry' 'mean fractal dimension'
 'radius error' 'texture error' 'perimeter error' 'area error'
 'smoothness error' 'compactness error' 'concavity error'
 'concave points error' 'symmetry error' 'fractal dimension error'
 'worst radius' 'worst texture' 'worst perimeter' 'worst area'
 'worst smoothness' 'worst compactness' 'worst concavity'
 'worst concave points' 'worst symmetry' 'worst fractal dimension']
</code></pre></div></div>

<ul>
  <li>
    <p>앞서, <code class="language-plaintext highlighter-rouge">cancer.data</code>에서 30개의 특성을 확인했다는 것을 염두하자</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">feature_names</code>속성을 확인하면 각 특성의 의미를 확인할 수 있다.</p>
  </li>
</ul>

<h4 id="1-4-boston-housing데이터셋">(1-4) <code class="language-plaintext highlighter-rouge">Boston Housing</code>데이터셋</h4>
<ul>
  <li>회귀 분석용 실제 데이터셋으로 보스턴 주택가격 데이터셋 또한 사용된다.</li>
  <li>이 데이터셋으로 할 작업은 범죄율, 찰스강 인접도, 고속도로 접근성 등의 정보를 이용해<br />
1970년대 보스턴 주변의 주택 평균 가격을 예측하는 것이다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="n">boston</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'데이터 형태 : '</span><span class="p">,</span> <span class="n">boston</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>데이터 형태 :  (506, 13)
</code></pre></div></div>

<ul>
  <li>
    <p>총 506개의 데이터 포인트와 13개의 특성이 확인된다.</p>
  </li>
  <li>이 데이터셋에서는 13개의 입력 특성뿐 아니라 특성끼리 곱하여(즉 상호작용) 의도적으로 확장할 것이다.</li>
  <li>즉 범죄율 / 고속도로 접근성의 개별 특성을 개별적으로 사용할 뿐만 아니라<br />
범죄율과 고속도로 접근성의 곱도 특성으로 생각한다는 의미이다.</li>
  <li>
    <p>이와 같이, 특성을 유도해내는 것을 <code class="language-plaintext highlighter-rouge">특성공학(feature engineering)</code>이라한다.</p>
  </li>
  <li>유도된 데이터셋은 <code class="language-plaintext highlighter-rouge">load_extended_boston</code> 함수를 사용하여 불러들일 수 있다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mglearn</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">load_extended_boston</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'X.shape : '</span><span class="p">,</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X.shape :  (506, 104)
</code></pre></div></div>

<ul>
  <li>원래 <code class="language-plaintext highlighter-rouge">Boston Housing</code> 데이터셋의 특성은 13개 였지만,<br />
13개에서 2개씩 (중복을 포함해) 짝지은 91개의 특성을 더해 총 104개가 된다.<br />
( (개별)13 + 13C2+(자기들끼리 짝지은 경우)13 )</li>
</ul>

<h4 id="2-k-최근접-이웃">(2) k-최근접 이웃</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">k-NN(k-Nearest Neighbors)</code>알고리즘
    <ul>
      <li>참조 : https://jhryu1208.github.io/data/2020/10/17/INTRODUCTION/</li>
      <li>머신러닝 알고리즘 중에서 가장 간단</li>
      <li>단순 저장이 모델을 만드는 과정의 전부</li>
      <li>새로운 데이터 포인트에 대해 예측할 땐 알고리즘이 훈련 데이터셋에서 가장 까운 데이터 포인트, 즉 <code class="language-plaintext highlighter-rouge">최근접 이웃</code>을 찾는다.</li>
    </ul>
  </li>
</ul>

<h4 id="2-1-k-최근접-이웃-분류">(2-1) k-최근접 이웃 분류</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mglearn</span><span class="p">.</span><span class="n">plots</span><span class="p">.</span><span class="n">plot_knn_classification</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110566-44299b80-171d-11eb-8dc1-d0d6641934c9.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_24_1" /></p>

<ul>
  <li>위 그림에서 추가된 데이터 포인트는 3개이다. (별모양으로 표시됨)</li>
  <li>
    <p>그리고 추가한 각 데이터포인트에서 가장 가까운 훈련 데이터 포인트를 찾아서 해당 클래스로 라벨링되는 것을 확인할 수 있다.</p>
  </li>
  <li>위의 <code class="language-plaintext highlighter-rouge">1-최근접 이웃 모델</code>과 달리</li>
  <li>좀 더 발전된 모델은 임의의 k개의 이웃을 고려하는 것이다.</li>
  <li>하나 이상의 이웃 데이터 포인트를 고려할 때, 라벨링은 <code class="language-plaintext highlighter-rouge">투표</code>를 통해서 이루어진다.</li>
  <li>즉, <u>가장 가까운 k개의 학습 데이터 포인터 중에서 더 많은 클래스를 따라서 시험 데이터가 라벨링된다는 의미이다.</u></li>
</ul>

<p><br /></p>

<ul>
  <li>다음 모델은 forge 데이터셋에 대한 <code class="language-plaintext highlighter-rouge">3-최근접 이웃 모델</code>의 예측이다.</li>
</ul>

<p>&lt;/br&gt;</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mglearn</span><span class="p">.</span><span class="n">plots</span><span class="p">.</span><span class="n">plot_knn_classification</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110567-44c23200-171d-11eb-8630-ad85b7db2770.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_26_1" /></p>

<ul>
  <li>
    <p>새 데이터 포인트 중 왼쪽 위의 것은 <code class="language-plaintext highlighter-rouge">n_neighbors = 1</code>일 때와 예측이 달라진 것을 알 수 있다.</p>
  </li>
  <li>위의 설명들은 모두 <code class="language-plaintext highlighter-rouge">이진 분류</code>에 대한 것이지만 <code class="language-plaintext highlighter-rouge">k-NN 알고리즘</code>은 <code class="language-plaintext highlighter-rouge">다중 분류</code>문제에도 사용할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">다중 분류</code>에서는 <u>각 클래스에 얼마나 많은 이웃들이 속해 있는지를 세어서 그 결과를 예측</u>하게 된다.</li>
</ul>

<p><br /></p>

<ul>
  <li>다음으로, <code class="language-plaintext highlighter-rouge">scikit-learn</code>을 사용해서 <code class="language-plaintext highlighter-rouge">k-최근접 이웃 알고리즘</code>을 적용하는 방법에 관하여 살펴볼 것이다.</li>
  <li>먼저 일반화 성능을 평가할 수 있도록 데이터를 <code class="language-plaintext highlighter-rouge">훈련 세트</code>와 <code class="language-plaintext highlighter-rouge">테스트 세트</code>로 나눈다.</li>
</ul>

<p>&lt;/br&gt;</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mglearn</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">make_forge</span><span class="p">()</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># KNeighborsClassifier 객체 생성
# 이웃의 수 3
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="n">clf</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>훈련 세트를 사용하여 분류 모델을 학습시킨다.</li>
  <li>여기서(<code class="language-plaintext highlighter-rouge">KNeighborsClassifier</code>) 학습시킨다는 것은 예측할 때 이웃을 찾을 수 있도록 데이터를 저장하는 것이다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KNeighborsClassifier(n_neighbors=3)
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">predict</code> 메서드를 호출해서 예측한다.</li>
  <li>테스트 세트의 각 데이터 포인트에 대해 훈련 세트에서 가장 가까운 이웃을 계산한 다음 가장 많은 클래스를 찾는다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'테스트 세트 예측 :'</span><span class="p">,</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>테스트 세트 예측 : [1 0 1 0 1 0 0]
</code></pre></div></div>

<ul>
  <li>모델이 얼마나 잘 일반화되었는지 평가하기 위해 <code class="language-plaintext highlighter-rouge">score</code> 메서드에 테스트 데이터와 테스트 레이블을 넣어 호출한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'테스트 세트 정확도 : {:.2f}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">clf</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>테스트 세트 정확도 : 0.86
</code></pre></div></div>

<ul>
  <li>[결과]
    <ul>
      <li>이 모델의 정확도는 86% 이다.</li>
      <li>즉 모델이 테스트 데이터셋에 있는 샘플 중 86%를 정확히 예측하였다는 의미이다.</li>
    </ul>
  </li>
</ul>

<h4 id="2-2-kneighborsclassifier-분석">(2-2) <code class="language-plaintext highlighter-rouge">KNeighborsClassifier</code> 분석</h4>

<ul>
  <li>2차원 데이터셋이므로 가능한 모든 테스트 포인트의 예측을 xy평면에 그려볼 수 있다.</li>
  <li>그리고 각 데이터 포인트가 속한 클래스에 따라 평면에 색을 칠한다.</li>
  <li>이렇게하면 알고리즘이 클래스 0과 클래스 1로 지정한 영역으로 나뉘는 <code class="language-plaintext highlighter-rouge">결정 경계(decision boundary)</code>를 확인할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li>다음 코드는 이웃이 하나, 셋, 아홉 개일 때의 <code class="language-plaintext highlighter-rouge">결정 경계</code>를 보여준다.</li>
</ul>

<p>&lt;/br&gt;</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110569-455ac880-171d-11eb-8620-07ceb47b8484.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_39_0" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="k">for</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">axes</span><span class="p">):</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">n_neighbors</span><span class="p">).</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">mglearn</span><span class="p">.</span><span class="n">plots</span><span class="p">.</span><span class="n">plot_2d_separator</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="p">.</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">mglearn</span><span class="p">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">"{} neighbors"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'feature 0'</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'feature 1'</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110570-455ac880-171d-11eb-9ce3-d233c8868ae0.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_40_0" /></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">n_neighbors = 1</code>일 때,<br />
모델링이 학습 데이터 셋에 가까운 결정 경계를 만들어낸다.<br />
즉, 학습 데이터 셋에 잘 맞는 복잡한 모델을 만든다는 것이다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">n_neighbors</code>가 증가할 수록 더 부드러운 결정 경계를 만든다.</li>
  <li>이는 학습 데이터 셋과 조금 동떨어질 수 있는 단순한 모델을 만든다는 것이다.</li>
  <li>
    <p>다시 말해 <u>이웃을 적게하면 모델의 복잡도가 높아지고 많이 사용하면 복잡도가 낮아진다.</u></p>
  </li>
  <li>모델의 복잡도와 일반화 사이의 관계를 입증할 수 있는지 살펴볼 것이다.
    <ul>
      <li>유방암 데이터셋이 이용된다.</li>
      <li>훈련 세트와 테스트 세트로 나누고, 이웃 수에 따라 평가한다.</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_breast_cancer</span>

<span class="n">cancer</span> <span class="o">=</span> <span class="n">load_breast_cancer</span><span class="p">()</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
    <span class="n">cancer</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cancer</span><span class="p">.</span><span class="n">target</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">cancer</span><span class="p">.</span><span class="n">target</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">66</span><span class="p">)</span>

<span class="n">training_accuracy</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">test_accuracy</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># 1 에서 10 까지 n_neighbors 를 적용
</span><span class="n">neighbors_settings</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>

<span class="k">for</span> <span class="n">n_neighbors</span> <span class="ow">in</span> <span class="n">neighbors_settings</span><span class="p">:</span>
    <span class="c1"># 모델 생성
</span>    <span class="n">clf</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">)</span>
    <span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="c1"># 훈련 세트 정확도 저장
</span>    <span class="n">training_accuracy</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">clf</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
    <span class="c1"># 일반화 정확도 저장
</span>    <span class="n">test_accuracy</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">clf</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>

<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors_settings</span><span class="p">,</span> <span class="n">training_accuracy</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">"train_acc"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors_settings</span><span class="p">,</span> <span class="n">test_accuracy</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">"test_acc"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">"accuracy"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">"n_neighbors"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;matplotlib.legend.Legend at 0x1d12c3651c0&gt;
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110571-45f35f00-171d-11eb-9215-df8c32c45466.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_43_1" /></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">과대적합</code>과 <code class="language-plaintext highlighter-rouge">과소적합</code>의 특징을 확인할 수 있다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">과대적합</code> =&gt; 이웃의 수가 하나일 때는
    <ul>
      <li>훈련 데이터에 대한 예측이 완벽하다.</li>
      <li>테스트 세트의 정확도는 이웃을 많이 사용했을 때보다 낮다. (모델이 너무 복잡해진다)</li>
      <li>쉽게말하면, 훈련 데이터에서는 너무 복잡하기 때문에 A = A인 경우와 A != A+0.000000000000001 경우처럼 극단적인 판단 기준을 가진다.
        <ul>
          <li>그래서 훈련 데이터의 경우 정확한 적중률을 보여주지만,</li>
          <li>테스트 데이터에서는 정확도가 낮아지는 것을 볼 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">과소적합</code> =&gt; 이웃의 수가 늘어나면
    <ul>
      <li>모델은 단순해지고 훈련 데이터의 정확도는 줄어든다.</li>
      <li>이웃의 수가 늘어나는 어느 순간부터 모델이 너무 단순해져서 정확도가 낮아진다.</li>
      <li>쉽게말하면, 훈련 데이터에 관해서는 모델이 너무 단순해서 A = A+1과 같이 판단 기준이 낮아진다.
        <ul>
          <li>그래서 훈련 데이터의 경우 적중률이 매우 저조한 것을 볼 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><u>이렇게 머신러닝에서는 다양한 케이스에 대해서 체크하여  
최적의 모델 즉 위와같이 정확도가 가장 좋을 때인 중간 정도인 6개를 사용한 경우를 찾아야한다.</u></li>
</ul>

<h4 id="2-3-k---최근접-이웃-회귀">(2-3) k - 최근접 이웃 회귀</h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">k-최근접 알고리즘</code>은 <code class="language-plaintext highlighter-rouge">회귀 분석</code>에서도 사용된다.</p>
  </li>
  <li>다음 예제에서 wavve 데이터 셋을 이용해서 이웃이 하나인 최근접 이웃을 사용할 것이다.</li>
  <li>최근접 점이 1개일때는 그냥 가장 가까운 데이터 포인트와 같은 값을 가지게 된다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mglearn</span><span class="p">.</span><span class="n">plots</span><span class="p">.</span><span class="n">plot_knn_regression</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110572-45f35f00-171d-11eb-9dea-ca0118c3245b.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_47_0" /></p>

<ul>
  <li>이 경우에서도 이웃을 둘 이상 사용하여 <code class="language-plaintext highlighter-rouge">회귀 분석</code>을 진행할 수 있다.</li>
  <li>여러 개의 최근접 이웃을 사용할 땐 이웃 간의 평균이 예측된다.
    <ul>
      <li>이웃이 1일때와 3일때의 target 위치를 비교하면 어떤 의미인지 쉽게 와닿는다.</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mglearn</span><span class="p">.</span><span class="n">plots</span><span class="p">.</span><span class="n">plot_knn_regression</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110573-468bf580-171d-11eb-81ac-fd77f1ac5c8d.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_49_0" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">scikit-learn</code>에서 <code class="language-plaintext highlighter-rouge">회귀</code>를 위한 <code class="language-plaintext highlighter-rouge">k-최근접 이웃 알고리즘</code>은 <code class="language-plaintext highlighter-rouge">KNeighborsRegressor</code>에 구현되어있다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mglearn</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">make_wave</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">=</span> <span class="mi">40</span><span class="p">)</span>

<span class="c1"># wave 데이터셋을 훈련 세트와 테스트 세트로 나눈다.
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># 이웃의 수를 3으로 하여 모델의 객체를 만든다.
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># 훈련 데이터와 타깃을 사용하여 모델을 학습시킨다.
</span><span class="n">reg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>KNeighborsRegressor(n_neighbors=3)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'테스트 세트 예측:</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>테스트 세트 예측:
 [-0.05396539  0.35686046  1.13671923 -1.89415682 -1.13881398 -1.63113382
  0.35686046  0.91241374 -0.44680446 -1.13881398]
</code></pre></div></div>

<ul>
  <li>역시 <code class="language-plaintext highlighter-rouge">score</code>메서드를 사용해 모델을 평가할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">score</code>메서드는 <code class="language-plaintext highlighter-rouge">회귀</code>일 땐 <code class="language-plaintext highlighter-rouge">결정계수(coefficient of determination)</code>인 <code class="language-plaintext highlighter-rouge">R^2</code>값을 반환한다.
    <ul>
      <li>0과 1사이의 값이 된다.</li>
      <li>1의 경우는 완벽한 예측이고, 0은 훈련 세트의 출력값인 y_train의 평균으로만 예측하는 모델의 경우이다.</li>
      <li>예측과 타깃이 상반된 경향을 가지는 경우 음수의 값을 가질 수 있다.</li>
      <li>결정계수의 식은 아래와 같다. y는 타깃값,  y-는 타깃 값의 평균값, y^는 모델의 예측값이다.
        <ul>
          <li>R^2 = (1−∑(y−y^)^2) / (∑(y−y¯)^2)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'테스트 세트 R^2 : {:.2f}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>테스트 세트 R^2 : 0.83
</code></pre></div></div>

<h4 id="2-4-kneighborsregressor-분석">(2-4) <code class="language-plaintext highlighter-rouge">KNeighborsRegressor</code> 분석</h4>

<ul>
  <li>1차원 데이터 셋에 대해 예측이 어떤식으로 이루어지는지 시각화 할 수 있다.
    <ul>
      <li>이를 위해 x축을 따라 많은 포인트를 생성해 테스트 데이터셋을 만든다.</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">mglearn</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">make_wave</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1"># linsapce 함수는 파이썬의 numpy 모듈에 포함된 함수로써
# 1차원의 배열 만들기,
# 그래프에서 수평축의 간격 만들기 등에 매우 편리하게 사용할 수 있는 함수이다.
# 아래 같은 경우는 -3부터 3까지 1000개의 데이터 포인트를 만든다.
# reshape 함수의 경우 다음 링크 참조 https://rfriend.tistory.com/345
# reshape의 결과로 [-3, ... , 3]까지의 1차원 배열이 1000행 1열의 형태로 바뀌엇다.
</span><span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1000</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110574-468bf580-171d-11eb-9ef6-86446f7d53c2.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_58_0" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1000</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>
<span class="k">for</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">axes</span><span class="p">):</span>
    <span class="c1"># make predictions using 1, 3, or 9 neighbors
</span>    <span class="n">reg</span> <span class="o">=</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">)</span>
    <span class="n">reg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="s">'^'</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">mglearn</span><span class="p">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">,</span> <span class="s">'v'</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">mglearn</span><span class="p">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    

    <span class="n">ax</span><span class="p">.</span><span class="n">set_title</span><span class="p">(</span>
                    <span class="s">"{} neighbor(s)</span><span class="se">\n</span><span class="s"> train score: {:.2f} test score: {:.2f}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
                        <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">),</span>
                        <span class="n">reg</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">"Feature"</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">"Target"</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">legend</span><span class="p">([</span><span class="s">"Model predictions"</span><span class="p">,</span> <span class="s">"Training data/target"</span><span class="p">,</span> <span class="s">"Test data/target"</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">"best"</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/53929665/97110577-47248c00-171d-11eb-8325-4749d3d69069.png" alt="2020-10-25-SUPERVISED_LEARNING_1_k-NN_59_0" /></p>

<ul>
  <li>위 그림에서 볼 수 있듯이 
<u>이웃을 하나만 사용할 때는 훈련 세트의 각 데이터 포인트가 예측에 주는 영향이 커서 예측값이 훈련 데이터 포인트를 모두 지나간다. 하지만, 이는 매우 불안정한 예측을 만들어낸다.  
이웃을 많이 사용하면 훈련 데이터에는 잘 안 맞을 수 있지만 안정된 예측을 얻게 된다.</u>   (이웃 3,9개의 경우가 1개의 경우보다 score가 높음)</li>
</ul>

<h4 id="2-5-장단점과-매개변수">(2-5) 장단점과 매개변수</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">k-NN 알고리즘</code>의 장점
    <ul>
      <li>알고리즘의 이해가 쉬우면서도 별다른 조정 없이도 합리적인 성능을 보여준다.</li>
      <li>복잡한 머신 러닝 테크닉을 사용하기 이전에 기본적으로 사용해볼만한 알고리즘으로 모델 구축이 매우 빠르다는 측면도 장점으로 작용한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">k-NN 알고리즘</code>의 단점
    <ul>
      <li>특성의 수 또는 데이터 포인트가 많아지면(즉 훈련 세트가 매우 많으면) 예측이 느려진다.</li>
      <li>특성 값 대부분이 0인 (즉 희소한) 데이터셋과는 특히 잘 작동하지 않는다.</li>
      <li><code class="language-plaintext highlighter-rouge">k-최근접 이웃 알고리즘</code>이 이해하긴 쉽지만, 예측이 느리고 많은 특성을 처리하는 능력이 부족해 현업에서는 잘 쓰지 않는다.
        <ul>
          <li><u>이런 단점이 없는 알고리즘이 다음에 설명될 `선형 모델`이다.</u></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

:ET