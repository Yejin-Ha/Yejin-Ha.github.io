I"<ul>
  <li>본 포스팅은 BigQuery사용 중 자주 이용하고 헷갈려하는 변환 함수들에 관하여 정리한 글입니다.</li>
  <li>GCP 공식 가이드를 기반으로 작성됩니다.</li>
  <li>지속적으로 기록될 예정입니다.</li>
</ul>

<hr />
<h3 id="-1-format_datatype-함수-">[ 1. FORMAT_(DataType) 함수 ]</h3>

<pre><code class="language-SQL">FORMAT_[DATE/DATETIME/TIMESTAMP]( [format_string], [DATE/DATETIME/TIMESTAMP_expr] )
</code></pre>
<ul>
  <li>지정된 <code class="language-plaintext highlighter-rouge">format_string</code>에 따라 타임스탬프의 형식을 지정한다.<br />ex1) 20201021 DATE 자료형 =&gt; 2020-10-21<code class="language-plaintext highlighter-rouge"> STRING</code> 자료형<br />ex2) 20201021 00:00:00 DATETIME 자료형 =&gt; 2020-10-21 <code class="language-plaintext highlighter-rouge">STRING</code> 자료형<br />ex3)2020-10-21 00:00:00 UTC TIMESTAMP 자료형 =&gt; 2020-10-21 <code class="language-plaintext highlighter-rouge">STRING</code> 자료형</li>
  <li>반환되는 데이터 유형은 ☑<code class="language-plaintext highlighter-rouge">STRING</code>이다.
    <ul>
      <li>FORMAT_(DataType)함수는 데이터의 포맷을 자유롭게 변경할 수 있는 장점을 가지고 있지만, 복잡한 쿼리에서는 날짜데이터에서 STRING으로 변경된 데이터 필드를 다시 날짜데이터로 바꾸는 번거로움을 경험할 수 있다.</li>
      <li>따라서, 쿼리가 단순하지 않을 것이라 예상되면 다음의 쿼리를 대신 사용할 것을 추천한다.</li>
    </ul>

    <pre><code class="language-SQL">  EXTRACT(DATE FROM 날짜컬럼)
</code></pre>
  </li>
  <li>zone 적용하기</li>
</ul>

<p>기존 UTC형식으로 표기된 날짜를 KST형식으로 바꾸고 날짜와 시간을 추출하기 위해서 나는 기존에는 항상 아래와 같이 수행했다. 아래처럼 사용하면 쿼리가 길어지고 처리시간이 길어질 뿐더러 가시성도 함수가 복잡해질수록 떨어진다는 단점이이있다.</p>

<pre><code class="language-SQL">FORMAT_TIMESTAMP(‘%Y%m%d %T’, 
				TIMESTAMP_ADD([UTC로 표기된 expr], INTERVAL 9 HOUR))
</code></pre>

<p><br /></p>

<p>하지만 FORMAT_TIMESTAMP함수를 아래와 같이 사용하면 위에서 했던거처럼 길게 함수를 적을 필요가 없다. (왜 지금까지 몰랐던걸까 ㅠ.ㅠ…)</p>

<pre><code class="language-SQL">FORMAT_TIMESTAMP(‘%Y%m%d %T’, 
				[UTC로 표기된 expr], ‘Asia/Seoul’[‘+9’로 해도됨])
</code></pre>

<p><br /></p>

<hr />
<h3 id="-2-parse_datatype-함수-">[ 2. PARSE_(DataType) 함수 ]</h3>

<pre><code class="language-SQL">PARSE_[DATE/DATETIME/TIMESTAMP]( [format_string], [DATE/DATETIME/TIMESTAMP_string] )
</code></pre>

<ul>
  <li>DATE/DATETIME/TIMESTAMP의 <code class="language-plaintext highlighter-rouge">STRING</code> 표현을 각각 ☑<code class="language-plaintext highlighter-rouge">DATE/DATETIME/TIMESTAMP</code>객체로 반환한다.</li>
  <li><u>[DATE/DATETIME/TIMESTAMP_string]의 각 요소는 [format_string]에 해당하는 요소여야 한다.</u></li>
  <li><code class="language-plaintext highlighter-rouge">FORMAT_(DataType)</code>과 마찬가지로 Parse함수도 zone을 이용하여 시각을 바꿀수 있다.</li>
</ul>

<pre><code class="language-SQL"># ex)
SELECT 
	PARSE_TIMESTAMP(‘%Y-%m-%d’, UTC_ts_expr, ‘Asia/Seoul’) —— timestamp객체가 KST시각으로 변환됨
</code></pre>

<hr />
<h3 id="-3-timestamp_micros-함수-">[ 3. TIMESTAMP_MICROS 함수 ]</h3>

<pre><code class="language-SQL">TIMESTAMP_MICROS(int64_expression)
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">int64-expression</code>( ex. 1230219000000000 )을 마이크로초 수로 해석하여 <code class="language-plaintext highlighter-rouge">TIMESTAMP</code>형태로 반환한다. <br />ex) 1230219000000000 =&gt; 2008-12-25 15:30:00 UTC</li>
</ul>

:ET