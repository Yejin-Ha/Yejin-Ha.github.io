I"a<p>소수를 판단하는 알고리즘인 <b>에라토스테네스의 체</b>에 관하여 알아보자.</p>

<p><br /></p>

<hr />

<h2 id="에라토스테네스의-체"><span style="color:navy">에라토스테네스의 체</span></h2>

<ul>
  <li>수학에서 <strong>소수(Prime Number)</strong>를 가장 빠르게 식별하는 알고리즘이다.
    <ul>
      <li>*소수 : 1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수</li>
    </ul>
  </li>
  <li>특정 숫자의 배수는 소수가 아니다는 개념으로 부터 생성되었다.
    <ul>
      <li>1보다 큰 자연수(즉, 2 ~ $n$ 까지)의 집합에서 특정 수의 배수들을 모두 제거한 뒤에 제거되지 않은 숫자를 소수라고 판단하는 러프한 방식의 알고리즘이다 
  (이때 특정 수인 자기 자신은 지우지 않는다).</li>
      <li>넓은 숫자의 범위에서 이 알고리즘을 손으로 수행하면 오랜 시간이 걸리겠지만, 프로그래밍에서는 상당히 효과적이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="how-to"><span style="color:navy">How to?</span></h2>

<p>2 ~ 120까지의 연속적인 숫자 집합에서 소수를 식별하기 위해<br />
<strong>에라토스테네스의 체</strong> 알고리즘을 적용해보자.</p>

<ol>
  <li>2부터 120사이의 숫자를 모두 나열한다.</li>
  <li>2의 배수(특정 수의 배수)를 반복해서 모두 지운다. 
(이때 특정 수인 2 자기 자신은 제외한다.)</li>
  <li>남아있는 수 중 3의 배수(특정 수의 배수)를 반복해서 모두 지운다. 
(이때 특정 수인 3 자기 자신은 제외한다.)</li>
  <li>4의 경우 2의 배수를 지울 때 지워졌으므로,
남아있는 수 중 5의 배수(특정 수의 배수)를 반복해서 모두 지운다.
(이때 특정 수인 5 자기 자신은 제외한다.)</li>
  <li>6의 경우 2의 배수를 지울 때 지워졌으므로,
남아있는 수 중 7의 배수(특정 수의 배수)를 반복해서 모두 지운다.
(이때 특정 수인 7 자기 자신은 제외한다.)</li>
  <li>특정 수를 제외한 모든 배수가 지워질 때 까지 이를 반복하면, 최종적으로 소수만이 남는다.</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/53929665/128386880-178b80a3-e07a-4213-8205-2dd744239786.gif" alt="Sieve_of_Eratosthenes_animation" /></p>

<p><br /></p>

<h2 id="에라토스테네스의-체-구현하기"><span style="color:navy">에라토스테네스의 체 구현하기</span></h2>

<p>알고리즘을 구현하기 전에 반복 작업을 줄여주기 위한 <br />다음의 정리에 관해서 먼저 알아보고자 한다.</p>

<blockquote>
  <p>3개 이상의 소수로 구성된 합성수는 그 수의 제곱근보다 작거나 같은 약수를 갖는다.</p>
</blockquote>

<p><br /></p>

<p>위의 정리는 아래와 같이 증명할 수 있다.</p>

<ul>
  <li>$n$을 합성수(*1과 자기 자신 이외의 약수로 이루어진 수)라고 한다.  <br /> ( ∴ $n = ab$ , $1 &lt; a, b &lt; n$ )</li>
  <li>$a, b$가 “둘 다” $\sqrt{n}$보다 크다고 가정해보자. ( ∴  $a, b &gt; \sqrt{n}$   )</li>
  <li>이때,  $a*b &gt; \sqrt{n} * \sqrt{n}$  →  $( ab &gt; n ) ≠ ( ab = n )$ 이 되므로 위의 가정은 모순된다.</li>
  <li>따라서,  귀류법에 의해서 “$a, b$ 중 하나는 $\sqrt{n}$ 보다 작다”.</li>
</ul>

<p><br /></p>

<p>위의 정리는 2 ~ $n$ 사이의 숫자 배열에서 소수를 색인하는데 걸리는 반복을 감소시킬 수 있다.</p>

<ul>
  <li>2 ~ $n$  사이에  소수가 아닌 양의 정수    $p$ 와 $q$가 있으며 $p &lt; q$ 를 만족한다.</li>
  <li>이때, $q$의 약수는 $p$의 약수보다 크거나 같기 때문에</li>
  <li>2 ~ $n$ 사이의 배열안의 숫자가 가지는 모든 약수 중 가장 큰 약수는 $\sqrt{n}$보다 작을 것이다.</li>
  <li>따라서, 이를 이용하면 에라토스테네스 알고리즘에서 배수를 지우는 과정이 $\sqrt{n}$회 이하로 줄일 수 있다.</li>
</ul>

<p><br /></p>

<p>이를 이용해 알고리즘을 파이썬 함수로 구현하면 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">prime_list</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># 총 n개의 요소를 가진 배열 생성(모든 배열의 원소를 소수(TRUE)라고 간주한다.)
</span>    <span class="n">sieve</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

    <span class="c1"># 위에서 언급한 정의 이용
</span>    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># i가 소수인 경우 / 2(첫 번째 특정 수)부터 먼저 들어온다.
</span>        <span class="k">if</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> 
            <span class="c1"># 리스트의 인덱스가 특정 수 i의 배수와 동일할 경우 
</span>	    <span class="c1"># 해당 인덱스의 값을 False로 변환한다.
</span>            <span class="c1"># 2의 경우, sieve[2], sieve[4], ...의 값들을 False로 변환한다.
</span>            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> 
                <span class="n">sieve</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span> 

    <span class="c1"># 소수 목록 산출
</span>    <span class="c1"># 리스트의 인덱스 값이 True에 해당하는 인덱스 번호만 리스트로 반환
</span>    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">]</span>
</code></pre></div></div>

<p><br /></p>

<hr />

<h2 id="references">References</h2>

<ul>
  <li><a href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4">wikipedia : 에라토스테네스의_체</a></li>
  <li><a href="https://readonly.wiki/w/%EC%86%8C%EC%9D%B8%EC%88%98%EB%B6%84%ED%95%B4">readonly.wiki : 소인수분해</a></li>
</ul>

:ET